package main

import (
	"image/color"
	"machine"
	"time"

	"avrmodem/proggy"

	"tinygo.org/x/drivers/buzzer"
	"tinygo.org/x/drivers/pcd8544"
	"tinygo.org/x/tinyfont"
)

const (
	statusOk    = "OK"
	statusError = "ERROR"
	statusNone  = ""
)

const CRLF = "\r\n"

type note struct {
	tone     float64
	duration float64
}

var (
	black       = color.RGBA{1, 1, 1, 255}
	l     int16 = 1
)

// 1NCE Logo
var Image = []byte{
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
	0x80, 0x80, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0x80, 0x80, 0x80, 0x80,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xc0, 0xf0, 0xf8, 0x78, 0x7c, 0x3e,
	0x1f, 0x1f, 0x0f, 0x0f, 0x87, 0xc7, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0x03, 0x03, 0x07, 0x07,
	0x07, 0x0f, 0x0f, 0x0f, 0x1f, 0x3f, 0x3e, 0xfc, 0xfc, 0xf8, 0xf0, 0xe0, 0xc0, 0x80, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xfe, 0xff, 0x3f, 0x07, 0x07,
	0x01, 0x00, 0x00, 0x18, 0x1c, 0x1e, 0x1e, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0f,
	0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x07, 0x07,
	0x07, 0x87, 0x86, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0x87,
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0x1f, 0x00, 0x00, 0x00, 0xf0, 0xff, 0xff, 0xff, 0x7f, 0xff, 0xff, 0xfe, 0xfc, 0xf0, 0xe0,
	0x80, 0x00, 0x00, 0xe0, 0xff, 0xff, 0xff, 0x3f, 0x87, 0xe0, 0xf0, 0xfc, 0xfe, 0x7f, 0x3f, 0x1f,
	0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0xc0, 0xe0, 0xf8, 0xfc, 0xfe,
	0xff, 0xdf, 0xcf, 0xcf, 0xcf, 0xcf, 0xcf, 0xcf, 0xcf, 0xcf, 0xcf, 0xcf, 0xcf, 0x0f, 0x00, 0x00,
	0x00, 0x00, 0x07, 0x1f, 0x70, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xfe, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0x0f, 0x01, 0x00, 0x80, 0xf8, 0xff, 0xff, 0xff, 0x3f, 0x07, 0x00, 0x00, 0x03,
	0x07, 0x1f, 0x3f, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x07, 0x00, 0x1f, 0x7f, 0xff, 0xff,
	0xff, 0xf8, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xe0, 0xe0, 0x00, 0x00, 0x00, 0x7f,
	0x7f, 0xff, 0xff, 0xff, 0xf3, 0xf3, 0xf3, 0xf3, 0xf3, 0xf3, 0xf3, 0xf3, 0xf3, 0xf3, 0xf3, 0x03,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
}

func writeLcd(display *pcd8544.Device, str string) {
	// we have only 4 strings on the display
	if l == 5 {
		display.ClearBuffer()
		l = 1
	}
	tinyfont.WriteLine(display, &proggy.TinySZ8pt7b, 0, l*10, str, black)
	display.Display()
	l++
	// time.Sleep(time.Millisecond * 2000)
}

func blinkDataLed(led *machine.Pin) {
	for i := 0; i < 3; i++ {
		led.High()
		time.Sleep(time.Millisecond * 3)
		led.Low()
		time.Sleep(time.Millisecond * 3)
	}
}

func main() {
	usbLed := machine.D31
	usbLed.Configure(machine.PinConfig{Mode: machine.PinOutput})
	usbLed.High()

	rstPin := machine.D3
	rstPin.Configure(machine.PinConfig{Mode: machine.PinOutput})
	scePin := machine.D4
	scePin.Configure(machine.PinConfig{Mode: machine.PinOutput})
	dcPin := machine.D5
	dcPin.Configure(machine.PinConfig{Mode: machine.PinOutput})

	machine.SPI0.Configure(machine.SPIConfig{})

	lcd := pcd8544.New(machine.SPI0, dcPin, rstPin, scePin)
	lcd.Configure(pcd8544.Config{})

	bzrPin := machine.D11
	bzrPin.Configure(machine.PinConfig{Mode: machine.PinOutput})
	bzr := buzzer.New(bzrPin)

	dataLed := machine.D53
	dataLed.Configure(machine.PinConfig{Mode: machine.PinOutput})
	dataLed.Low()

	notes := []note{
		{200, buzzer.Quarter},
		{50, 0.1},
		{20, 0.1},
		{40, 0.3},
		{20, 0.1},
		{40, 0.3},
		{100, buzzer.Quarter},
		{6000, buzzer.Half},
		{100, buzzer.Quarter},
	}

	var (
		b        = make([]byte, 24)
		answer   string
		status   string
		cmd      string
		first    int8
		last     int8
		sound    = true
		firstCmd = true
	)

	// Splash screen
	if err := lcd.SetBuffer(Image); err != nil {
		panic(err)
	}

	if err := lcd.Display(); err != nil {
		panic(err)
	}

	for {
		cmd = ""
		first = -1
		last = -1

		for {
			n, err := machine.UART0.Read(b)
			if err != nil {
				panic(err)
			}

			if n > 0 {
				blinkDataLed(&dataLed)
				for i := 0; i < n; i++ {
					if first < 0 && n >= 2 && b[i] == 'A' && b[i+1] == 'T' {
						first = int8(i + 2)
					}

					if b[i] == '\r' {
						last = int8(n - 1)
					}

					if b[i] == '\n' {
						last = int8(n - 2)
					}
				}

				if first >= 0 {
					if last < 0 {
						cmd += string(b[first:n])
						first = 0
					} else {
						cmd += string(b[first:last])
						break
					}
				}
			}

			time.Sleep(50 * time.Millisecond)
		}

		answer = ""
		status = statusOk

		if firstCmd {
			lcd.ClearDisplay()
			firstCmd = false
		}

		writeLcd(lcd, cmd)

		switch cmd {
		case "":

		case "E0":

		case "E1":

		case "+CFUN=1":

		case "+GCAP":
			answer = "+GCAP: +CGSM,+DS"

		case "+CMGF=1":

		case "+CMEE=2":

		case "&F0":

		case "+CGMI":
			answer = "Quectel"

		case "+GSN":
			answer = "866758043804166"

		case "+CGMM":
			answer = "EC25"

		case "+QGMR":
			answer = "EC25AVRMOCK"

		case "+CIMI":
			answer = "901405100004385"

		case "+QCCID":
			answer = "+QCCID: 89882806660000043853"

		case "+CGATT=1":
			if sound {
				for _, n := range notes {
					bzr.Tone(n.tone, n.duration)
					time.Sleep(10 * time.Millisecond)
				}
			}

		//case "+QICSGP=1,1,\"iot.1nce.net\",\"\",\"\",3":
		//
		//case "+QIACT=1":
		//
		//case "+QIDEACT=1":
		//
		//case "+QIACT?":
		//	answer = "+QIACT: 1,1,1,\"10.232.117.1\""

		case "+CGATT=0":

		case "+ATM0":
			sound = false

		default:
			status = statusError
		}

		if answer != "" {
			print(answer + CRLF)
			// writeLcd(lcd, cmd+": "+answer)
			time.Sleep(100 * time.Millisecond)
		}

		if status != statusNone {
			print(status + CRLF)
			// writeLcd(lcd, cmd+": "+status)
			time.Sleep(100 * time.Millisecond)
		}

		// runtime.GC()
	}
}
